
import os
import re
creds_path = "src/CREDS.py"
import math
import datetime
assert os.path.isfile(creds_path), "\n\nsrc.CREDS is not present in the folder\n Ask Ashad for the file\n\n"

from src.CREDS import GOOGLE_GEMINI_API_KEY

if not GOOGLE_GEMINI_API_KEY or GOOGLE_GEMINI_API_KEY == "YOUR_API_KEY_HERE":
    raise ValueError("Please set the GOOGLE_GEMINI_API_KEY in src.CREDS.py")

# os.environ["GOOGLE_API_KEY"] = GOOGLE_GEMINI_API_KEY


import random
import logging
from typing import List, Tuple, Dict
import google.generativeai as genai
from IPython.display import Markdown
from src.logger import Logger, log_time
from src.emotion_analyzer import EmotionAnalyzer


def get_today_date():
    return datetime.datetime.now().strftime("%Y-%m-%d")

class ContentGenerator:
    
    """
    A class to generate content based on a prompt using Google Gemini AI.
    """
    def __init__(self, api_key: str = GOOGLE_GEMINI_API_KEY):
        """
        Initialize the ContentGenerator with the API key.

        Args:
            api_key (str): The API key for Google Gemini AI.
        """
        genai.configure(api_key=api_key)
        self.logger = Logger("langchain_model", see_time=True)
        self.score_logger = Logger("score", see_time=True, console_log=True)
        self.model = genai.GenerativeModel("gemini-pro")
        self.emotion_analyzer = EmotionAnalyzer()
        self.emotions = ['admiration', 'amusement', 'anger', 'annoyance', 'approval', 'caring', 'confusion', 'curiosity', 'desire', 'disappointment', 'disapproval', 'disgust', 'embarrassment', 'excitement', 'fear', 'gratitude', 'grief', 'joy', 'love', 'nervousness', 'optimism', 'pride', 'realization', 'relief', 'remorse', 'sadness', 'surprise']
        self.positive_emotions = ['admiration', 'amusement', 'approval', 'caring', 'curiosity', 'excitement', 'gratitude', 'joy', 'love', 'optimism', 'pride', 'realization', 'relief', 'surprise']
        self.negative_emotions = ['anger', 'annoyance', 'confusion', 'desire', 'disappointment', 'disapproval', 'disgust', 'embarrassment', 'fear', 'grief', 'nervousness', 'remorse', 'sadness']
        
    def clean_question(self, question: str) -> str:
        """
        Clean the question text by removing any unwanted characters.

        Args:
            question (str): The question text.

        Returns:
            str: Cleaned question text
        """
        cleaned_ques = re.sub(r'\"[^\w\s]\"', '', question)
        cleaned_ques = re.sub(r'\*\*([^*]{0,10}?\b\w+\b[^*]{0,50}?)\*\*', '', cleaned_ques)
        cleaned_ques = cleaned_ques.replace('"', '')
        cleaned_ques = cleaned_ques.replace("\n", " ")
        cleaned_ques = cleaned_ques.replace("*", " ")
        # check if there are atmost 3 words before a comma, if so then remove till the comma
        print("__Python Print__", cleaned_ques)
        cleaned_ques = re.sub(r'^(\w+[ ]?),', '', cleaned_ques)
        print("__Python Print__", cleaned_ques)

        return cleaned_ques
    
    def generate_emotion(self) -> str:
        """
        Analyze a job description and infer an emotion.

        Args:
            job_description (str): The job description text.

        Returns:
            str: An inferred emotion from the list.
        """
        emotion = random.choice(self.emotions)
        self.logger.log_message(f"Inferred emotion: {emotion}", level=logging.DEBUG)
        return emotion

    def respond_to_query(self, emotion: str, job_desc: str) -> str:
        """
        Respond to a query based on the inferred emotion.

        Args:
            emotion (str): The inferred emotion.
            query (str): The query about the emotion.

        Returns:
            str: A response generated by the model.
        """
        prompt = f"Based on the emotion '{emotion}', what behavioral question would you ask related to this job?\n\nJob Description:\n{job_desc}\n\n"
        response = self.model.generate_content(prompt)
        self.logger.log_message(f"Response to query: {response.text}", level=logging.DEBUG)
        return response.text
    
    def interview(self, job_desc: str) -> Tuple[str, float]:
        """
        Generate an interview question based on the inferred emotion.

        Args:
            emotion (str): The inferred emotion.
            job_desc (str): The job description text.

        Returns:
            str: An interview question related to the emotion.
        """        
        total_score = 0.0
        current_score = 0.0
        for i, emotion in enumerate(self.emotions):
            question = self.respond_to_query(emotion, job_desc)
            question = self.clean_question(question)
            user_answer = input(f"Answer the question: {question}\n")
            self.logger.log_message(f"Question for emotion '{emotion}': {question}\nAnswer: {user_answer}", level=logging.DEBUG)
            if user_answer.lower() == "no":
                break
            top_emotion, score = self.emotion_analyzer.analyze_response_emotion(emotion, user_answer)
            if emotion in self.positive_emotions and top_emotion in self.positive_emotions:
                if score >= 0.5:  # Positive response to positive emotion
                    current_score = score * 10.0  # Good score
                else:  # Negative response to positive emotion
                    current_score = score * -5.0  # Bad score
            elif emotion in self.positive_emotions and top_emotion in self.negative_emotions:
                if score >= 0.5:
                    current_score = score * -10.0
                else:
                    current_score = score * 5.0
            elif emotion in self.negative_emotions and top_emotion in self.negative_emotions:
                if score >= 0.5:
                    current_score = score * -10.0
                else:
                    current_score = score * 5.0
            elif emotion in self.negative_emotions and top_emotion in self.positive_emotions:
                if score >= 0.5:
                    current_score = score * 10.0
                else:
                    current_score = score * -5.0
            else:  # Neutral emotion
                current_score = score * 7.5  # Neutral score
            total_score += current_score / (i + 1)
            self.score_logger.log_message(f"Score for emotion '{emotion}': {current_score:.2f}%")
            self.score_logger.log_message(f"Total score: {total_score:.2f}%")
           
        print(f"__Python Print__ Total score: {total_score:.2f}%")
        self.score_logger.log_message(f"Total score: {total_score:.2f}%")
        return total_score
    
    def interview_question(self, job_desc: str, question_index: int) -> Tuple[str, str]:
        """
        Generate an interview question based on the inferred emotion at the specified index.

        Args:
            job_desc (str): The job description text.
            question_index (int): The index of the question to generate.

        Returns:
            str: The interview question related to the emotion at the specified index.
        """
        print(question_index)
        if question_index < 0 or question_index >= 5:
            return -1, 'none', "No more questions, The interview has ended."

        emotion = self.emotions[question_index]
        prompt = f"Suppose you are conducting an behavorial interview, based on the emotion '{emotion}', you just have to ask a behavioral question (no headings, just a single question) related to this job?\n\nJob Description:\n{job_desc}\n\n"
        question = self.model.generate_content(prompt).text
        cleaned_question = self.clean_question(question)
        return 0, emotion, cleaned_question
    
    def score_answer(self, emotion: str, answer: str) -> float:
        """
        Score the answer based on the inferred emotion.

        Args:
            emotion (str): The inferred emotion.
            answer (str): The user's answer to the question.

        Returns:
            float: The score for the answer.
        """
        top_emotion, score = self.emotion_analyzer.analyze_response_emotion(answer)
        print(top_emotion, score)
        if emotion in self.positive_emotions and top_emotion in self.positive_emotions:
            if score >= 0.5:  # Positive response to positive emotion
                current_score = score * 10.0  # Good score
            else:  # Negative response to positive emotion
                current_score = score * -5.0  # Bad score
        elif emotion in self.positive_emotions and top_emotion in self.negative_emotions:
            if score >= 0.5:
                current_score = score * -10.0
            else:
                current_score = score * 5.0
        elif emotion in self.negative_emotions and top_emotion in self.negative_emotions:
            if score >= 0.5:
                current_score = score * -10.0
            else:
                current_score = score * 5.0
        elif emotion in self.negative_emotions and top_emotion in self.positive_emotions:
            if score >= 0.5:
                current_score = score * 10.0
            else:
                current_score = score * -5.0
        else:  # Neutral emotion
            current_score = score * 7.5  if score is not None else 0.0
        total_score = current_score * math.log10(len(answer.split()))  # Adjust score based on answer length
        if total_score <= 0.0:
            total_score = 0.0
        if total_score >= 10.0:
            if current_score < 8.0:
                total_score = 8.0
            else:
                total_score = 10.0
        self.score_logger.log_message(f"Score for emotion '{emotion}': {current_score:.2f}%")
        return total_score*10
    
    def get_report(self, chat_history: List[Dict[str, str]]) -> str:
        """
        Generate a report based on the chat history.

        Args:
            chat_history (List[Tuple[str, str]]): The chat history containing the questions and answers.

        Returns:
            str: A report summarizing the chat history.
        """
        report = ""
        for i, chat in enumerate(chat_history):
            question = chat['question']
            answer = chat['answer']
            score = chat['score']
            report += f"Question {i + 1}:\n{question}\n\nAnswer:\n{answer}\n\nScore: {score:.2f}%\n\n"
            
        report = self.generate_report(report).replace('*','')
        return report
    
    def generate_report(self, chat_history: str):
        """
        Use gemini to generate a detailed report about the itnerview

        Args:
            chat_history (str): The chat history containing the questions and answers.
        """
        prompt = f"You are a hiring manager conducting an emotional intelligence interview. Based on the chat history, generate a detailed report (email) about the interview. Analyse and score on the basis of Goleman EQ Theory\n\nChat History:\n{chat_history}\n\n"
        response = self.model.generate_content(prompt).text
        return response
        
if __name__ == "__main__":
    content_generator = ContentGenerator()
    emotion = content_generator.generate_emotion()
    job_desc = """
    **Position Title:** Software Engineer

**Description:**
Seeking a Software Engineer to develop high-quality software solutions in collaboration with cross-functional teams. Responsibilities include designing, coding, testing, and debugging software applications. 

**Qualifications:**
- Bachelor's degree in Computer Science or related field
- Proven experience in software development
- Proficiency in programming languages like Java, Python, or JavaScript
- Familiarity with web development frameworks and/or mobile app development is a plus
- Strong problem-solving and communication skills

**Benefits:**
- Competitive salary
- Health, dental, and vision insurance
- Flexible work schedule
- Opportunities for professional development

**How to Apply:**
Submit resume and cover letter to [Contact Information].
"""
    # emotion, question = content_generator.interview_question(job_desc, 1)
    # answer = input("Enter: ")
    # print(content_generator.score_answer(emotion, answer))
    chat_hiroty = [
    {
        "question": "You've been working on a critical project for months, and suddenly your team leader decides to change the project direction. How would you handle this change emotionally?",
        "answer": "I would be really mad and probably just quit. It's not fair to change everything last minute.",
        "score": 2.0
    },
    {
        "question": "You encounter a bug in the code that you've been working on for days, and the deadline is looming. Describe how you would manage the frustration and pressure.",
        "answer": "I would panic and stress out. Bugs are the worst, and I hate dealing with them.",
        "score": 1.5
    },
    {
        "question": "You receive harsh criticism from a colleague during a code review. How do you handle the emotional impact and ensure it doesn't affect your motivation?",
        "answer": "I would just ignore them. They probably don't know what they're talking about anyway.",
        "score": 2.5
    },
    {
        "question": "Your project gets delayed due to unforeseen technical challenges, causing frustration among team members. How would you manage the team's emotions and maintain morale?",
        "answer": "I would tell everyone to stop complaining and just get back to work. We have a job to do.",
        "score": 3.0
    },
    {
        "question": "You're working on a project where your ideas are not being considered by the team, leading to feelings of being undervalued. How would you address this emotional challenge?",
        "answer": "I would probably just stop contributing altogether. If they don't appreciate my ideas, then why bother?",
        "score": 2.0
    },
    {
        "question": "You successfully deliver a project ahead of schedule, but your contribution is not acknowledged by the management. How would you handle feelings of disappointment and underappreciation?",
        "answer": "I would complain to my manager about not getting credit. It's not fair that others get recognized and I don't.",
        "score": 2.5
    },
    {
        "question": "Your project encounters a major setback, and you're worried about the impact on your reputation within the company. How would you manage feelings of anxiety and self-doubt?",
        "answer": "I would probably just start looking for another job. I don't want to be associated with failure.",
        "score": 2.0
    }
]


    os.makedirs("TestReports", exist_ok=True)
    with open("TestReports/test2.txt", "w") as file:
        file.write(content_generator.get_report(chat_history=chat_hiroty))